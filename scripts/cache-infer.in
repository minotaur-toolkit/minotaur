#!/usr/bin/env perl

# Copyright (c) 2020-present, author: Zhengyang Liu (liuz@cs.utah.edu).
# Distributed under the MIT license that can be found in the LICENSE file.
# borrowed from souper

use warnings;
use strict;
use Redis;
use Getopt::Long;
use File::Temp;
use Time::HiRes;
use BSD::Resource;

eval { require Sys::CPU; Sys::CPU->import(); };

my $NPROCS = 40;
$NPROCS = Sys::CPU::cpu_count() if defined(&Sys::CPU::cpu_count);

my $CPU_LIMIT = 15 * 60;
my $RAM_LIMIT = 4 * 1024 * 1024 * 1024;

sub usage() {
    print <<"END";
Options:
  -n                        number of CPUs to use (default=$NPROCS)
  -tag                      add this tag to cache entries, and skip entries with it
  -separate-files           put each souper invocation's output into its own output file
  -souper-debug-level       pass this integer debug level to Souper
  -verbose                  print extra output
  -unix			    talk to Redis using UNIX domain sockets
END
    exit -1;
}

my $tag = "x";
my $VERBOSE = 0;
my $SAVE_TEMPS=1;
my $UNIX = 0;

GetOptions(
    "n=i" => \$NPROCS,
    "tag=s" => \$tag,
    "verbose" => \$VERBOSE,
    "unix" => \$UNIX,
    "separate-files" => \$SAVE_TEMPS,
    ) or usage();

my $REDISPORT = 6379;

my $minotaur = "@CMAKE_BINARY_DIR@/opt-minotaur.sh";
my $llvmdis = "@LLVM_BINARY_DIR@/bin/llvm-dis";

my $r;
if ($UNIX) {
    $r = Redis->new(sock => "@CMAKE_BINARY_DIR@/cache.sock");
} else {
    $r = Redis->new(server => "localhost:" . $REDISPORT);
}
$r->ping || die "no server?";
my @all_keys = $r->keys('*');

sub infer($) {
    (my $opt) = @_;
    (my $fh, my $tmpfn) = File::Temp::tempfile();
    print $fh $opt;
    $fh->flush();
    open INF, "${llvmdis} < $tmpfn 2>&1 |";
    my $output = "";
    my $success = 0;
    while (my $line = <INF>) {
        $success = 1 if ($line =~ /success/);
        next if ($line =~ /^;/);
        $output .= $line;
    }
    close INF;
    close $fh;


    print("solving $output\n");
    my $pid = $$;

    my $OFN;

    if (1) {
        $OFN = "tmp_${pid}.log";
        system "${minotaur} < $tmpfn > $OFN 2>&1";
        open my $OF, ">>$OFN" or die;
        #print $OF "\n\n$cmd\n\n";
        #print $OF "$k\n\n";
        close $OF;
    }

    unlink $tmpfn;
    exit(0);

    # my $ok = 0;
    # my $failed = 0;
    # my @lines = <$INF>;
    # for (@lines) {
    #     if ($_ =~ /Failed/) {
    #         $failed = 1;
    #         next;
    #     }
    #     if ($_ =~ /successfully/) {
    #         $ok = 1;
    #         next;
    #     }
    # }
    # close $INF;
    # close $fh;
    # unlink $tmpfn;

    # my $red;
    # if ($UNIX) {
    # $red = Redis->new(sock => "@CMAKE_BINARY_DIR@/cache.sock");
    # } else {
    # $red = Redis->new(server => "localhost:" . $REDISPORT);
    # }
    # $red->ping || die "no server?";
    # $red->hset($k, "cache-infer-tag" => $tag);

    # if ($ok) {
    #     open(FH, '>', "rewrite-${pid}") or die $!;
    #     for(@lines) {
    #       print FH $_;
    #     }
    #     close(FH);
    #     exit 0;
    # } else {
    #     exit 1;
    # }
}

my $num_running = 0;
my $good = 0;
my $fail = 0;

sub wait_for_one() {
    my $xpid = wait();
    die if $xpid == -1;
    $num_running--;
    my $result = $? >> 8;
    if ($result == 0) {
        $good++;
    } else {
        $fail++;
    }
}

my $status_cnt;
my $status_opct;
my $status_total;

sub status() {
    print ".";
    $status_cnt++;
    my $pct = int(100.0 * $status_cnt/$status_total);
    if ($pct > $status_opct) {
        $status_opct = $pct;
        print "$pct %\n";
    }
}

my $opid = $$;
my $skip = 0;

print scalar(@all_keys)." expressions\n";

my $count = 0;

my %toprint;
my %ir;
my %rewrite;
my %timestamp;
my %fn_name;
my %noopt;

foreach my $opt (@all_keys) {
    my %h = $r->hgetall($opt);

    my $result = $h{"rewrite"};
    my $time   = $h{"timestamp"};
    my $fn     = $h{"fn"};

    #$ir{$opt} = infer($opt);
    $toprint{$opt} = 1;
    $fn_name{$opt} = $fn;
    $timestamp{$opt} = $time;
}

foreach my $opt (keys %toprint) {
    status() if $VERBOSE;
    my $ir   = $ir{$opt};
    # if (defined $result && $result eq $tag) {
    #     $skip++;
    #     next;
    # }
    wait_for_one() unless $num_running < $NPROCS;
    die unless $num_running < $NPROCS;
    print("solving $count\n");
    $count ++;
    my $pid = fork();
    die unless $pid >= 0;
    if ($pid == 0) {
        #die "setrlimit RSS" unless setrlimit(RLIMIT_RSS, $RAM_LIMIT, $RAM_LIMIT);
        #die "setrlimit VMEM" unless setrlimit(RLIMIT_VMEM, $RAM_LIMIT, $RAM_LIMIT);
        infer ($opt);
    }
    # make sure we're in the parent
    die unless $$ == $opid;
    $num_running++;
}

wait_for_one() while ($num_running > 0);

print "$good optimizations\n";
print "$fail not-optimizations\n";
print "$skip skipped due to tag match\n";