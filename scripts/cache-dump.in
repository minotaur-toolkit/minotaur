#!/usr/bin/env perl

# Copyright (c) 2020-present, author: Zhengyang Liu (liuz@cs.utah.edu).
# Distributed under the MIT license that can be found in the LICENSE file.
# borrowed from souper

use warnings;
use strict;
use Redis;
use Getopt::Long;
use File::Temp;
use Time::HiRes;

my $llvmas  = "@LLVM_BINARY_DIR@/bin/llvm-as";
my $llvmopt = "@LLVM_BINARY_DIR@/bin/opt";
my $llvmdis = "@LLVM_BINARY_DIR@/bin/llvm-dis";

sub runit ($) {
    my $cmd = shift;
    my $res = (system "$cmd");
    return $? >> 8;
}

sub usage() {
    print <<'END';
Options:
  -dumpall                            dump all LHSs
  -tofiles                            dump all LHSs to files
  -sort=timestamp|costdiff|reduce|cutsize    sort optimizations
  -verbose
END
    exit -1;
}

my $REDISPORT = 6379;
my $DUMPALL = 0;
my $TOFILES = 0;
my $SORT = "timestamp";
my $VERBOSE = 0;
my $UNIX = 0;

GetOptions(
    "dumpall" => \$DUMPALL,
    "tofiles" => \$TOFILES,
    "redis-port=i" => \$REDISPORT,
    "sort=s" => \$SORT,
    "verbose" => \$VERBOSE,
    ) or usage();
usage() unless ($SORT eq "timestamp" ||
                $SORT eq "costdiff" ||
                $SORT eq "reduce" ||
                $SORT eq "cutsize");

my $noopt_count=0;

my $r;
if ($UNIX) {
    $r = Redis->new(sock => "@CMAKE_BINARY_DIR@/cache.sock");
} else {
    $r = Redis->new(server => "localhost:" . $REDISPORT);
}
$r->ping || die "no server?";
my @all_keys = $r->keys('*');

print "; Inspecting ".scalar(@all_keys)." Redis values\n";

sub parse($) {
    #(my $opt, my $RHS) = @_;
    (my $opt) = @_;
    (my $fh, my $tmpfn) = File::Temp::tempfile();
    print $fh $opt;
    $fh->flush();
    open INF, "${llvmdis} < $tmpfn 2>&1 |";
    my $output = "";
    my $success = 0;
    while (my $line = <INF>) {
        $success = 1 if ($line =~ /success/);
        next if ($line =~ /^;/);
        $output .= $line;
    }
    close INF;
    close $fh;
    unlink $tmpfn;
    return $output;
}


my %toprint;
my %ir;
my %rewrite;
my %costafter;
my %costbefore;
my %costdiff;
my %reduce;
my %timestamp;
my %fn_name;
my %noopt;
my %optbc;
my %cutsize;


if ($DUMPALL) {
    print "; Dumping all ".scalar(keys @all_keys)." rewrites\n";
    my $count = 0;
    foreach my $opt (@all_keys) {
        my %h = $r->hgetall($opt);
        my $time   = $h{"timestamp"};
        my $fn     = $h{"fn"};
        my $ir     = parse($opt);
        if ($TOFILES) {
            open(my $fh, ">", "dump_$count.ll");
            print $fh $ir;
            $fh->flush();
            close $fh;
        } else {
            print $ir, "\n";
            print "timestamp: $time\n";
            print "in fn: $fn\n";
            print "\n------------------------------------------------------\n";
        }
        $count = $count + 1;
    }
    exit(0);
}

foreach my $opt (@all_keys) {
    my %h = $r->hgetall($opt);

    my $result = $h{"rewrite"};
    my $time   = $h{"timestamp"};
    my $fn     = $h{"fn"};

    $ir{$opt} = parse($opt);
    $fn_name{$opt} = $fn;
    $timestamp{$opt} = $time;

    $noopt{$opt} = $result eq "<no-sol>";
    if ($noopt{$opt}) {
        $noopt_count++;
    } else {
        my $ca     = $h{"costafter"};
        my $cb     = $h{"costbefore"};
        my $obc    = $h{"optimizedbc"};
        if ($cb == 0) {
            $cb = 1;
        }
        if ($ca == 0) {
            $ca = 1;
        }
        $optbc{$opt} = parse($obc);
        $toprint{$opt} = 1;
        $costafter{$opt} = $ca;
        $costbefore{$opt} = $cb;
        $costdiff{$opt} = $cb - $ca;
        $reduce{$opt} = ($cb - $ca * 1.0) / $cb;
        $rewrite{$opt} = $result;
        $cutsize{$opt} = length($optbc{$opt});
    }
}


print "; Discarding ${noopt_count} not-optimizations leaving ".
    scalar(keys %toprint)." optimizations\n";

# print "\n\n";

sub bytimestamp { $timestamp{$b} <=> $timestamp{$a} }
sub bycostdiff { $costdiff{$b} <=> $costdiff{$a} }
sub byreduce { $reduce{$b} <=> $reduce{$a} }
sub bycutsize { $cutsize{$b} <=> $cutsize{$a} }

my $byx;
$byx = \&bytimestamp if ($SORT eq "timestamp");
$byx = \&bycostdiff if ($SORT eq "costdiff");
$byx = \&byreduce if ($SORT eq "reduce");
$byx = \&bycutsize if ($SORT eq "cutsize");


my $count = 0;
foreach my $opt (sort $byx keys %toprint) {
    my $ir   = $ir{$opt};
    my $time = $timestamp{$opt};
    my $fn   = $fn_name{$opt};
    my $rewrite = $rewrite{$opt};
    my $ca = $costafter{$opt};
    my $cb = $costbefore{$opt};
    my $obc = $optbc{$opt};

    if ($TOFILES) {
        open(my $fh, ">", "dump_$count.src.ll");
        print $fh $ir, "\n";
        $fh->flush();
        close $fh;
        open($fh, ">", "dump_$count.tgt.ll");
        print $fh $obc, "\n";
        $fh->flush();
        close $fh;
    } else {
        print "; src ---------------------------------------------------\n";
        print $ir, "\n";
        print "; tgt ---------------------------------------------------\n";
        print $obc, "\n";
        print "; stats -------------------------------------------------\n";
        print "; minotaur_rewrite: $rewrite \n";
        print "; minotaur_cost-before: $cb\n";
        print "; minotaur_cost-after: $ca\n";
        print "; minotaur_timestamp: $time\n";
        print "; minotaur_fn: $fn\n";
    }
    $count = $count + 1;

    # print "\n";
    # print "; total static profile = $sprofiles{$opt}\n";
    # my %h = %{$sprofile_locs{$opt}};
    # foreach my $k (sort { $h{$b} <=> $h{$a} } keys %h) {
    #     next if ($k eq "");
    #     print "; sprofile $h{$k} \"$k\"\n";
    # }
    # print "; total dynamic profile = $dprofiles{$opt}\n";
    # %h = %{$dprofile_locs{$opt}};
    # foreach my $k (sort { $h{$b} <=> $h{$a} } keys %h) {
    #     next if ($k eq "");
    #     print "; dprofile $h{$k} \"$k\"\n";
    # }
}

# my $cnt = 0;
# foreach my $opt (keys %toprint) {
#     $cnt += $sprofiles{$opt};
# }
# print "; overall total static profile weight = $cnt\n";
# print "; $tagged were tagged by cache_infer, $untagged were not\n";
